{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HyDLPy","text":"<p>\ud83c\udf0a A Python Framework for Building Hybrid Hydrological Models with Deep Learning</p> <p> </p> <p>A Python implementation of the hybrid hydrological modeling framework inspired by HydroModels.jl</p>"},{"location":"#overview","title":"\ud83d\ude80 Overview","text":"<p>HyDLPy is a cutting-edge Python framework that seamlessly integrates traditional process-based hydrological models with modern deep learning techniques. Built on PyTorch and PyTorch Lightning, it enables researchers and practitioners to construct hybrid models that combine the interpretability of physics-based approaches with the flexibility and predictive power of neural networks.</p> <p>\u26a0\ufe0f WARNING: This is a private library for internal use only. It is highly unstable and the API is subject to change without notice. DO NOT USE IN PRODUCTION.</p>"},{"location":"#key-features","title":"\ud83c\udfaf Key Features","text":"<ul> <li>\ud83d\udd2c Symbolic Model Definition: Define hydrological processes using SymPy equations with automatic compilation to PyTorch</li> <li>\ud83e\udde0 Hybrid Architecture: Combine process-based models with neural networks for enhanced performance</li> <li>\u26a1 High Performance: GPU-accelerated computations with automatic differentiation support</li> <li>\ud83d\udd27 Modular Design: Flexible, plug-and-play components for different modeling needs</li> <li>\ud83d\udcca Built-in Models: Pre-implemented HBV, XAJ, and ExpHydro models ready to use</li> <li>\ud83c\udf10 Advanced Routing: Sophisticated river routing with differentiable Muskingum-Cunge method</li> <li>\ud83d\udcc8 Comprehensive Metrics: Multiple loss functions and evaluation metrics for hydrological modeling</li> <li>\ud83d\udd0c PyTorch Lightning Integration: Easy training, validation, and deployment workflows</li> </ul>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#hydrology-core","title":"\ud83d\udd2c Hydrology Core","text":"<p>The heart of the framework - a differentiable, physics-based hydrological model defined using symbolic equations:</p> <ul> <li>Symbolic Definition: Use SymPy to define complex hydrological processes</li> <li>Automatic Compilation: Equations are automatically compiled to optimized PyTorch functions</li> <li>Topological Sorting: Dependencies are automatically resolved for correct computation order</li> <li>Parameter Management: Built-in parameter bounds and optimization support</li> </ul>"},{"location":"#parameter-estimators","title":"\ud83e\udde0 Parameter Estimators","text":"<p>Neural network components that learn to estimate model parameters:</p> <ul> <li>Static Parameter Estimator: MLPs that estimate parameters from basin characteristics</li> <li>Dynamic Parameter Estimator: LSTMs/GRUs that estimate time-varying parameters from meteorological data</li> <li>Flexible Architecture: Support for various neural network architectures</li> </ul>"},{"location":"#routing-modules","title":"\ud83c\udf0a Routing Modules","text":"<p>Advanced river routing capabilities:</p> <ul> <li>Differentiable Muskingum-Cunge (DMC): Physics-based routing with automatic differentiation</li> <li>Neural Routing: MLP-based routing for complex river networks</li> <li>Flexible Integration: Easy to add custom routing methods</li> </ul>"},{"location":"#built-in-models","title":"\ud83d\udcca Built-in Models","text":"<p>Ready-to-use implementations of popular hydrological models:</p> <ul> <li>HBV Model: Complete implementation of the HBV conceptual model</li> <li>XAJ Model: Xinanjiang model for humid regions</li> <li>ExpHydro: Experimental model for research and development</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>PyTorch 2.8 or higher</li> <li>CUDA (optional, for GPU acceleration)</li> </ul>"},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install hydlpy\n</code></pre>"},{"location":"#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/chooron/hydlpy.git\ncd hydlpy\npip install -e .\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li><code>torch&gt;=2.8</code> - PyTorch for deep learning computations</li> <li><code>pytorch-lightning&gt;=2.5</code> - High-level PyTorch wrapper for training</li> <li><code>sympy&gt;=1.14</code> - Symbolic mathematics for model definition</li> <li><code>pydantic&gt;=2.11</code> - Data validation and settings management</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import torch\nfrom hydlpy.model import DplHydroModel\n\n# Create configuration (ExpHydro example)\nconfig = {\n    \"hydrology_model\": {\n        \"name\": \"exphydro\",\n        \"input_names\": [\"prcp\", \"pet\", \"temp\"],\n    },\n    # Estimated parameters must exactly match hydrology model parameters (static \u222a dynamic)\n    \"static_estimator\": {\n        \"name\": \"mlp\",\n        \"estimate_parameters\": [\"Tmin\", \"Tmax\", \"Df\", \"Smax\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\"],\n    },\n    \"dynamic_estimator\": {\n        \"name\": \"lstm\",\n        \"estimate_parameters\": [\"Qmax\", \"f\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\"],\n    },\n    \"warm_up\": 100,\n    \"hru_num\": 8,\n    \"optimizer\": {\"lr\": 1e-3},\n}\n\nmodel = DplHydroModel(config)\n\n# Prepare input data (shapes must match input_names)\ntime_len, basin_num = 200, 20\nbatch = {\n    \"x_phy\": torch.rand((time_len, basin_num, 3)),      # [T, B, F]\n    \"x_nn_norm\": torch.rand((time_len, basin_num, 3)),  # reserved\n    \"xc_nn_norm\": torch.rand((time_len, basin_num, 3)), # inputs for dynamic estimator\n    \"c_nn_norm\": torch.rand((basin_num, 6)),            # inputs for static estimator\n}\n\nwith torch.no_grad():\n    outputs = model(batch)\n    # outputs is a dict of fluxes and states, e.g. outputs[\"flow\"], outputs[\"soilwater\"]\n    print(list(outputs.keys())[:5])\n</code></pre>"},{"location":"#building-a-custom-hydrological-model","title":"Building a Custom Hydrological Model","text":"<pre><code>from hydlpy.hydrology import HydrologicalModel, HydroParameter, HydroVariable, variables\nfrom sympy import S, Min, Max, Eq, tanh\n\n# Define parameters with bounds\nTmin = HydroParameter(\"Tmin\", default=-1.0, bounds=(-5.0, 5.0))\nSmax = HydroParameter(\"Smax\", default=250.0, bounds=(100.0, 400.0))\n\n# Define variables\ntemp = HydroVariable(\"temp\")\nprcp = HydroVariable(\"prcp\")\nsnowpack = HydroVariable(\"snowpack\")\nsoilwater = HydroVariable(\"soilwater\")\n\n# Define intermediate fluxes\nrainfall, snowfall, melt, flow = variables(\"rainfall, snowfall, melt, flow\")\n\n# Define equations\nfluxes = [\n    Eq(rainfall, (tanh(5.0 * (Tmin - temp)) + 1.0) * 0.5 * prcp),\n    Eq(snowfall, (tanh(5.0 * (temp - Tmin)) + 1.0) * 0.5 * prcp),\n    Eq(melt, (tanh(5.0 * (temp - Tmin)) + 1.0) * 0.5 * Min(snowpack, 2.5 * (temp - Tmin))),\n    Eq(flow, Max(soilwater - Smax, 0))\n]\n\ndfluxes = [\n    Eq(snowpack, snowfall - melt),\n    Eq(soilwater, rainfall + melt - flow)\n]\n\n# Create the model\nmodel = HydrologicalModel(fluxes=fluxes, dfluxes=dfluxes, hru_num=16)\n\n# Run the model\nstates = torch.randn(16, 2)  # [H, S]\nforcings = torch.randn(16, 2)  # [H, F]\n\nfluxes_out, new_states = model(forcings.unsqueeze(0).unsqueeze(1), states)\nprint(f\"Fluxes shape: {fluxes_out.shape}\")\nprint(f\"New states shape: {new_states.shape}\")\n</code></pre>"},{"location":"#training-with-pytorch-lightning-optional","title":"Training with PyTorch Lightning (optional)","text":"<pre><code>import pytorch_lightning as pl\nfrom hydlpy.data import HydroDataModule\n\n# Create data module\n# data_module = HydroDataModule(...)\n\n# Create trainer\ntrainer = pl.Trainer(\n    max_epochs=100,\n    accelerator=\"gpu\" if torch.cuda.is_available() else \"cpu\",\n    devices=1\n)\n\n# Train the model\n# trainer.fit(model, data_module)\n</code></pre>"},{"location":"#built-in-models_1","title":"\ud83d\udcca Built-in Models","text":"<p>HyDLPy comes with several pre-implemented hydrological models ready for immediate use:</p>"},{"location":"#hbv-model","title":"\ud83c\udf28\ufe0f HBV Model","text":"<p>The HBV (Hydrologiska Byr\u00e5ns Vattenbalansavdelning) model is a conceptual rainfall-runoff model widely used in Nordic countries.</p> <p>Key Features:</p> <ul> <li>Snow accumulation and melt processes</li> <li>Soil moisture accounting</li> <li>Three-layer response function</li> <li>Temperature-based snow/rain separation</li> </ul> <p>Parameters:</p> <ul> <li><code>TT</code>: Temperature threshold for snow/rain separation</li> <li><code>CFMAX</code>: Degree-day factor for snowmelt</li> <li><code>FC</code>: Field capacity of soil</li> <li><code>BETA</code>: Shape parameter for soil moisture function</li> <li><code>k0</code>, <code>k1</code>, <code>k2</code>: Recession coefficients</li> </ul>"},{"location":"#xaj-model","title":"\ud83c\udf27\ufe0f XAJ Model","text":"<p>The Xinanjiang (XAJ) model is designed for humid regions and features a unique runoff generation mechanism.</p> <p>Key Features:</p> <ul> <li>Three-layer soil moisture storage</li> <li>Free water storage concept</li> <li>Nash cascade routing</li> <li>Evapotranspiration calculation</li> </ul> <p>Parameters:</p> <ul> <li><code>Wum</code>, <code>Wlm</code>, <code>Wdm</code>: Upper, lower, and deep layer storage capacities</li> <li><code>b</code>: Shape parameter for runoff generation</li> <li><code>Smax</code>: Free water storage capacity</li> <li><code>Ki</code>, <code>Kg</code>: Interflow and groundwater recession coefficients</li> </ul>"},{"location":"#exphydro-model","title":"\ud83d\udd2c ExpHydro Model","text":"<p>An experimental model designed for research and development purposes.</p> <p>Key Features:</p> <ul> <li>Simplified snow processes</li> <li>Basic soil moisture accounting</li> <li>Configurable parameter bounds</li> <li>Ideal for testing new concepts</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>For detailed documentation, examples, and API reference, visit:</p> <ul> <li>\ud83d\udcd6 Full Documentation</li> <li>\ud83d\udd2c Model Building Guide</li> </ul>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<ul> <li>HydroModels.jl: Original Julia implementation by chooron</li> <li>PyTorch Team: For the excellent deep learning framework</li> <li>SymPy Community: For symbolic mathematics capabilities</li> <li>Hydrological Research Community: For decades of model development and validation</li> </ul>"},{"location":"#support","title":"\ud83d\udcde Support","text":"<ul> <li>\ud83d\udcac GitHub Discussions - Community support and questions</li> <li>\ud83d\udc1b Issue Tracker - Bug reports and feature requests</li> <li>\ud83d\udce7 Email: jingxin0107@qq.com</li> </ul>   **\u2b50 If you find HyDLPy useful, please give it a star on GitHub! \u2b50**  Made with \u2764\ufe0f for the hydrological modeling community"},{"location":"build_hydrological_model/","title":"Documentation: <code>HydrologicalModel</code>","text":"<p>The <code>HydrologicalModel</code> is a powerful PyTorch <code>nn.Module</code> that programmatically compiles a process-based hydrological model from a set of symbolic equations defined with SymPy.</p> <p>It enables researchers and practitioners to define complex, interdependent physical processes in a clear mathematical format. The class then automatically analyzes these equations, determines the correct computational order, and compiles them into a high-performance, parallelized PyTorch function suitable for modern machine learning workflows, including automatic differentiation and GPU acceleration.</p>"},{"location":"build_hydrological_model/#1-installation-and-dependencies","title":"1. Installation and Dependencies","text":"<p>Before using the model, ensure you have the necessary libraries installed.</p> <pre><code>pip install torch sympy pytest\n</code></pre> <ul> <li>torch: For all numerical computations and neural network functionalities.</li> <li>sympy: For defining the symbolic equations of the model.</li> <li>pytest: For running the unit tests (optional but recommended).</li> </ul>"},{"location":"build_hydrological_model/#2-defining-a-model","title":"2. Defining a Model","text":"<p>Creating a <code>HydrologicalModel</code> instance involves three main steps: defining the symbols, writing the equations, and instantiating the class.</p>"},{"location":"build_hydrological_model/#step-21-define-symbols","title":"Step 2.1: Define Symbols","text":"<p>First, you must define all variables and parameters of your model using the provided <code>HydroParameter</code> and <code>HydroVariable</code> classes.</p> <ul> <li><code>HydroParameter</code>: Represents a model parameter. It requires a <code>default</code> value and can optionally take <code>bounds</code> for optimization. Each parameter will be a trainable <code>nn.Parameter</code> within the model.</li> <li><code>HydroVariable</code>: Represents any non-parameter symbol, such as a state variable (e.g., <code>snowpack</code>), a forcing variable (e.g., <code>temp</code>), or an intermediate flux.</li> </ul> <pre><code># Import necessary classes\nfrom hydlpy.hydrology_cores import HydrologicalModel, HydroParameter, HydroVariable, variables\nfrom sympy import S, Min, Max, exp, tanh\nimport sympy\nimport torch\n\n# --- Define Parameters ---\nTmin = HydroParameter(\"Tmin\", default=-1.0, bounds=(-5.0, 5.0))\nTmax = HydroParameter(\"Tmax\", default=1.0, bounds=(-5.0, 5.0))\nDf = HydroParameter(\"Df\", default=2.5, bounds=(0.0, 10.0))\nSmax = HydroParameter(\"Smax\", default=250.0, bounds=(100.0, 400.0))\nQmax = HydroParameter(\"Qmax\", default=10.0, bounds=(0.0, 50.0))\nf = HydroParameter(\"f\", default=0.05, bounds=(0.0, 0.2))\n\n# --- Define State and Forcing Variables ---\ntemp = HydroVariable(\"temp\")\nprcp = HydroVariable(\"prcp\")\nlday = HydroVariable(\"lday\")\nsnowpack = HydroVariable(\"snowpack\")\nsoilwater = HydroVariable(\"soilwater\")\n\n# --- Define intermediate flux symbols ---\n# The 'variables' helper can create multiple symbols from a string\nrainfall, snowfall, melt, pet, evap, baseflow, surfaceflow, flow = variables(\n    \"rainfall, snowfall, melt, pet, evap, baseflow, surfaceflow, flow\"\n)\n</code></pre>"},{"location":"build_hydrological_model/#step-22-write-the-equations","title":"Step 2.2: Write the Equations","text":"<p>Next, define the model's physical processes as a list of <code>sympy.Eq</code> objects. The <code>HydrologicalModel</code> will automatically determine the correct computational order, even if the equations are provided out of order.</p> <p>Note: Use <code>sympy.S()</code> to wrap any numerical constants (like <code>29.8</code> or <code>17.3</code>) to ensure type compatibility during compilation.</p> <pre><code># Helper function for smooth transitions\ndef step_func(x):\n    return (tanh(5.0 * x) + 1.0) * 0.5\n\n# Define equations for intermediate fluxes\nfluxes = [\n    sympy.Eq(pet, S(29.8) * lday * 24 * 0.611 * exp((S(17.3) * temp) / (temp + 237.3)) / (temp + 273.2)),\n    sympy.Eq(rainfall, step_func(Tmin - temp) * prcp),\n    sympy.Eq(snowfall, step_func(temp - Tmax) * prcp),\n    sympy.Eq(melt, step_func(temp - Tmax) * Min(snowpack, Df * (temp - Tmax))),\n    sympy.Eq(evap, step_func(soilwater) * pet * Min(soilwater, Smax) / Smax),\n    sympy.Eq(baseflow, step_func(soilwater) * Qmax * exp(-f * (Smax - Min(Smax, soilwater)))),\n    sympy.Eq(surfaceflow, Max(soilwater, Smax) - Smax),\n    sympy.Eq(flow, baseflow + surfaceflow),\n]\n\n# Define differential equations for state variables\ndfluxes = [\n    sympy.Eq(snowpack, snowfall - melt),\n    sympy.Eq(soilwater, (rainfall + melt) - (evap + flow)),\n]\n</code></pre>"},{"location":"build_hydrological_model/#step-23-instantiate-the-model","title":"Step 2.3: Instantiate the Model","text":"<p>Finally, create an instance of the <code>HydrologicalModel</code>, passing the equations and the desired <code>hidden_size</code>. The <code>hidden_size</code> determines how many parallel computational units (e.g., Hydrologic Response Units or HRUs) the model will simulate.</p> <pre><code># Instantiate a model to simulate 16 HRUs in parallel\nmodel = HydrologicalModel(fluxes=fluxes, dfluxes=dfluxes, hidden_size=16)\n\n# The model is now compiled and ready to use!\nprint(f\"Model initialized with {model.hidden_size} HRUs.\")\nprint(f\"State variables: {model.state_names}\")\nprint(f\"Forcing variables: {model.forcing_names}\")\n</code></pre>"},{"location":"build_hydrological_model/#3-running-the-model","title":"3. Running the Model","text":"<p>The <code>HydrologicalModel</code> instance is a standard <code>nn.Module</code> and is called via its <code>forward</code> method. It expects pure <code>torch.Tensor</code> inputs with a shape of <code>(batch_size, hidden_size, num_features)</code>.</p>"},{"location":"build_hydrological_model/#input-and-output-tensors","title":"Input and Output Tensors","text":"<ul> <li><code>states</code> (Input): A tensor containing the current values of the state variables (e.g., <code>snowpack</code>, <code>soilwater</code>).<ul> <li>Shape: <code>(batch_size, hidden_size, num_states)</code></li> </ul> </li> <li><code>forcings</code> (Input): A tensor containing the current values of the forcing variables (e.g., <code>temp</code>, <code>prcp</code>).<ul> <li>Shape: <code>(batch_size, hidden_size, num_forcings)</code></li> </ul> </li> <li><code>output</code> (Return): A single tensor containing all calculated intermediate fluxes and the updated state variables for the next time step.<ul> <li>Shape: <code>(batch_size, hidden_size, num_outputs)</code></li> </ul> </li> </ul> <p>The order of features in the tensors corresponds to the alphabetically sorted lists stored in <code>model.state_names</code>, <code>model.forcing_names</code>, and <code>model.output_names</code>.</p>"},{"location":"build_hydrological_model/#example-running-a-single-time-step","title":"Example: Running a Single Time Step","text":"<pre><code># Define model dimensions\nBATCH_SIZE = 4\nN_HRUs = 16\n\n# Create an instance of the model\nmodel = HydrologicalModel(fluxes=fluxes, dfluxes=dfluxes, hidden_size=N_HRUs)\n\n# 1. Prepare random input tensors with the correct 3D shape\n# The order of features in the last dimension must match the model's name lists\nstates_tensor = torch.rand(BATCH_SIZE, N_HRUs, len(model.state_names))\nforcings_tensor = torch.rand(BATCH_SIZE, N_HRUs, len(model.forcing_names))\n\n# 2. Run the forward pass\n# This executes one time step of the model for all items in the batch and all HRUs\noutput_tensor = model(states_tensor, forcings_tensor)\n\n# 3. Interpret the output\nprint(f\"Input states shape: {states_tensor.shape}\")\nprint(f\"Output tensor shape: {output_tensor.shape}\")\n\n# Use the model's output_map to get the index of a specific variable\nflow_idx = model.output_map['flow']\nnew_soilwater_idx = model.output_map['soilwater']\n\n# Extract the flow for the first item in the batch across all 16 HRUs\nbatch_0_flow = output_tensor[0, :, flow_idx]\n\n# Extract the updated soilwater for the first item in the batch\nbatch_0_new_soilwater = output_tensor[0, :, new_soilwater_idx]\n\nprint(f\"Calculated flow for batch item 0 (all HRUs): {batch_0_flow.shape}\")\nprint(f\"Updated soilwater for batch item 0 (all HRUs): {batch_0_new_soilwater.shape}\")\n</code></pre>"},{"location":"configuration/","title":"Configuration and Input Conventions","text":"<p>This document describes the configuration fields of <code>DplHydroModel</code> and the input tensor format conventions.</p>"},{"location":"configuration/#top-level-configuration","title":"Top-level Configuration","text":"<pre><code>hydrology_model:\n  name: exphydro | hbv\n  input_names: [prcp, pet, temp]   # Must match the last dim of x_phy/xc_nn_norm\n\nstatic_estimator:\n  name: mlp | direct\n  estimate_parameters: [..]        # Static parameter names\n  input_names: [attr1, attr2, ...] # Static estimator inputs\n\ndynamic_estimator:\n  name: lstm\n  estimate_parameters: [..]        # Dynamic parameter names\n  input_names: [..]                # Dynamic estimator inputs\n\nwarm_up: 100\nhru_num: 8\noptimizer:\n  lr: 1e-3\n</code></pre> <p>Note: The union of static and dynamic estimated parameters must exactly match the hydrology model parameter set, otherwise model construction will fail.</p>"},{"location":"configuration/#input-tensor-shapes","title":"Input Tensor Shapes","text":"<ul> <li><code>x_phy</code>: <code>[T, B, F]</code> hydrology core forcings (<code>F=len(hydrology_model.input_names)</code>)</li> <li><code>x_nn_norm</code>: <code>[T, B, F]</code> reserved (same shape)</li> <li><code>xc_nn_norm</code>: <code>[T, B, F]</code> dynamic estimator inputs (<code>F=len(dynamic_estimator.input_names)</code>)</li> <li><code>c_nn_norm</code>: <code>[B, C]</code> static estimator inputs (<code>C=len(static_estimator.input_names)</code>)</li> </ul>"},{"location":"configuration/#example-exphydro","title":"Example (ExpHydro)","text":"<pre><code>config = {\n    \"hydrology_model\": {\"name\": \"exphydro\", \"input_names\": [\"prcp\", \"pet\", \"temp\"]},\n    \"static_estimator\": {\n        \"name\": \"mlp\",\n        \"estimate_parameters\": [\"Tmin\", \"Tmax\", \"Df\", \"Smax\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\"],\n    },\n    \"dynamic_estimator\": {\n        \"name\": \"lstm\",\n        \"estimate_parameters\": [\"Qmax\", \"f\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\"],\n    },\n    \"warm_up\": 100,\n    \"hru_num\": 8,\n}\n</code></pre>"},{"location":"configuration/#example-hbv","title":"Example (HBV)","text":"<pre><code>config = {\n    \"hydrology_model\": {\"name\": \"hbv\", \"input_names\": [\"P\", \"Ep\", \"T\"]},\n    \"static_estimator\": {\n        \"name\": \"mlp\",\n        \"estimate_parameters\": [\n            \"TT\", \"CFMAX\", \"CWH\", \"CFR\", \"FC\", \"LP\", \"BETA\", \"k1\", \"k2\", \"UZL\"\n        ],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\"],\n    },\n    \"dynamic_estimator\": {\n        \"name\": \"lstm\",\n        \"estimate_parameters\": [\"BETA\", \"PPERC\", \"k0\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\"],\n    },\n    \"warm_up\": 100,\n    \"hru_num\": 8,\n}\n</code></pre>"},{"location":"configuration/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Incomplete estimated parameter set: ensure static \u222a dynamic equals the hydrology parameter names</li> <li>Dimension mismatch: <code>input_names</code> must match the last dimension of inputs</li> <li>Missing <code>hru_num</code> or <code>warm_up</code></li> </ul>"},{"location":"estimators/","title":"Estimators","text":"<p>HyDLPy provides two types of parameter estimators:</p> <ul> <li>StaticEstimator: infers time-invariant parameters from basin attributes</li> <li>DynamicEstimator: infers time-varying parameters from meteorological time series</li> </ul> <p>The union of their output parameter names must equal the hydrology model parameter set.</p>"},{"location":"estimators/#static-estimator","title":"Static Estimator","text":"<ul> <li>Config fields:</li> <li><code>name</code>: <code>mlp</code> | <code>direct</code></li> <li><code>estimate_parameters</code>: list of output parameter names</li> <li><code>input_names</code>: list of attribute inputs</li> <li>Input shape: <code>c_nn_norm</code> is <code>[B, C]</code></li> <li>Output shape: each parameter is <code>[B, H]</code>, where <code>H=hru_num</code></li> </ul> <p>Example: <pre><code>static_cfg = {\n    \"name\": \"mlp\",\n    \"estimate_parameters\": [\"Tmin\", \"Tmax\", \"Df\", \"Smax\"],\n    \"input_names\": [\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\"],\n}\n</code></pre></p>"},{"location":"estimators/#dynamic-estimator","title":"Dynamic Estimator","text":"<ul> <li>Config fields:</li> <li><code>name</code>: <code>lstm</code></li> <li><code>estimate_parameters</code>: list of output parameter names</li> <li><code>input_names</code>: list of meteorological inputs</li> <li>Input shape: <code>xc_nn_norm</code> is <code>[T, B, F]</code></li> <li>Output shape: each parameter is <code>[T, B, H]</code></li> </ul> <p>Example: <pre><code>dynamic_cfg = {\n    \"name\": \"lstm\",\n    \"estimate_parameters\": [\"Qmax\", \"f\"],\n    \"input_names\": [\"attr1\", \"attr2\", \"attr3\"],\n}\n</code></pre></p>"},{"location":"estimators/#faq","title":"FAQ","text":"<ul> <li>Parameter names must align with hydrology names (static \u222a dynamic = hydrology set)</li> <li>Input dimensions must match <code>input_names</code></li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This section walks you through the minimal steps to run a hybrid hydrological model (ExpHydro) in HyDLPy.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<pre><code>pip install hydlpy\n</code></pre>"},{"location":"getting_started/#basic-example-exphydro","title":"Basic Example (ExpHydro)","text":"<pre><code>import torch\nfrom hydlpy.model import DplHydroModel\n\nconfig = {\n    \"hydrology_model\": {\n        \"name\": \"exphydro\",\n        \"input_names\": [\"prcp\", \"pet\", \"temp\"],\n    },\n    # The union of static and dynamic estimated parameters must exactly match the hydrology parameters\n    \"static_estimator\": {\n        \"name\": \"mlp\",\n        \"estimate_parameters\": [\"Tmin\", \"Tmax\", \"Df\", \"Smax\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\"],\n    },\n    \"dynamic_estimator\": {\n        \"name\": \"lstm\",\n        \"estimate_parameters\": [\"Qmax\", \"f\"],\n        \"input_names\": [\"attr1\", \"attr2\", \"attr3\"],\n    },\n    \"warm_up\": 100,\n    \"hru_num\": 8,\n}\n\nmodel = DplHydroModel(config)\n\ntime_len, basin_num = 200, 20\nbatch = {\n    \"x_phy\": torch.rand((time_len, basin_num, 3)),\n    \"x_nn_norm\": torch.rand((time_len, basin_num, 3)),\n    \"xc_nn_norm\": torch.rand((time_len, basin_num, 3)),\n    \"c_nn_norm\": torch.rand((basin_num, 6)),\n}\n\nwith torch.no_grad():\n    outputs = model(batch)\n    print(\"keys:\", list(outputs.keys())[:5])\n</code></pre>"},{"location":"getting_started/#faq","title":"FAQ","text":"<ul> <li>Required input keys: <code>x_phy</code>, <code>x_nn_norm</code>, <code>xc_nn_norm</code>, <code>c_nn_norm</code>.</li> <li><code>input_names</code> must match the last dimension of <code>x_phy</code>/<code>xc_nn_norm</code>.</li> <li>The (static \u222a dynamic) estimated parameters must equal the hydrology parameter set, otherwise the model constructor will raise an error.</li> </ul>"},{"location":"models/","title":"Built-in Hydrology Models","text":"<p>This section lists built-in models and key parameter names to help you configure estimators correctly.</p>"},{"location":"models/#exphydro","title":"ExpHydro","text":"<ul> <li>Inputs: <code>[prcp, pet, temp]</code></li> <li>Typical parameters: <code>[Tmin, Tmax, Df, Smax, Qmax, f]</code></li> <li>Split example:<ul> <li>Static: <code>[Tmin, Tmax, Df, Smax]</code></li> <li>Dynamic: <code>[Qmax, f]</code></li> </ul> </li> </ul>"},{"location":"models/#hbv","title":"HBV","text":"<ul> <li>Inputs: <code>[P, Ep, T]</code></li> <li>Reference parameters (based on implementation):</li> <li><code>TT</code>, <code>CFMAX</code>, <code>CWH</code>, <code>CFR</code>, <code>FC</code>, <code>LP</code>, <code>BETA</code>, <code>PPERC</code>, <code>UZL</code>, <code>k0</code>, <code>k1</code>, <code>k2</code></li> <li>Split example:</li> <li>Static: <code>TT, CFMAX, CWH, CFR, FC, LP, BETA, k1, k2, UZL</code></li> <li>Dynamic: <code>BETA, PPERC, k0</code></li> <li>Note: The union of static and dynamic must cover the full hydrology parameter set; overlap is allowed (e.g., BETA)</li> </ul> <p>Tip: the actual parameter names are defined in <code>hydlpy/hydrology/implements/*.py</code>. Check the source for ground truth.</p>"},{"location":"training/","title":"Training and Evaluation","text":"<p>This section shows how to train <code>DplHydroModel</code> with PyTorch Lightning (optional).</p>"},{"location":"training/#optimizer-and-loss","title":"Optimizer and Loss","text":"<ul> <li>Built-in optimizer: AdamW (set learning rate via <code>optimizer.lr</code>)</li> <li>Built-in loss: MSE (<code>torchmetrics.MeanSquaredError</code>); replaceable in a custom loop</li> </ul> <pre><code>from hydlpy.model import DplHydroModel\n\nconfig = {\n    # ... \u540c\u524d\u6587\u914d\u7f6e ...\n    \"optimizer\": {\"lr\": 1e-3},\n}\nmodel = DplHydroModel(config)\nopt = model.configure_optimizers()\n</code></pre>"},{"location":"training/#lightning-integration","title":"Lightning Integration","text":"<pre><code>import pytorch_lightning as pl\n# from hydlpy.data import HydroDataModule  # \u53ef\u9009\n\ntrainer = pl.Trainer(\n    max_epochs=10,\n    accelerator=\"gpu\" if torch.cuda.is_available() else \"cpu\",\n    devices=1,\n)\n\n# data_module = HydroDataModule(...)\n# trainer.fit(model, data_module)\n</code></pre>"},{"location":"training/#evaluation-and-inference","title":"Evaluation and Inference","text":"<ul> <li>Use <code>with torch.no_grad(): outputs = model(batch)</code> for inference</li> <li>Output is a dict: keys are flux/state names such as <code>flow</code>, <code>soilwater</code>, etc.</li> </ul>"},{"location":"training/#tips","title":"Tips","text":"<ul> <li>Ensure batch keys and shapes satisfy configuration requirements</li> <li>Validate forward stability on a small batch before full training</li> </ul>"}]}